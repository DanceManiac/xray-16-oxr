/*
	Gasmask breath shader			
	Author: Yohjimane
	OpenXRay Engine 2023
*/

#include "common.h"
#include "gasmask_common.h"

float fbm(float2 texcoord, int iterations) 
{
	float3 image_noise = s_breath_noise.Sample(smp_rtlinear, texcoord).xyz;
    float value = image_noise.x;
    float amplitude = 1.0;
    float frequency = 1.25; //play with is
    float total_weight = 2.5;

    for (int i = 0; i < iterations; i++) 
    {
        value += image_noise.x * amplitude;
        texcoord *= frequency;
        amplitude *= 1.25; //with this thing too
        total_weight += amplitude;
    }
    return value / total_weight;
}

float4 main(p_screen I) : SV_Target
{
	float3 image = s_image.Sample(smp_rtlinear, I.tc0).xyz;
	float3 image_blur = s_image_blurred.Sample(smp_rtlinear, I.tc0).xyz;
    //texcoord
    float2 texcoord = I.tc0;

    float3 noise = s_breath_noise.Sample(smp_rtlinear, I.tc0).xyz;
    float2 seed = noise.xy;
    float breath_idx = breath_control.w;
    seed = frac(seed + float2(breath_idx, breath_idx) * 0.38196601125); // disable to stop generating new versions
    
    //ratio correction (remember that only circle tc should be corrected)
    float4 circle_tc_pos;
    circle_tc_pos.xy = texcoord; //texcoord
    circle_tc_pos.x -= 0.5;
    circle_tc_pos.x *= screen_res.x * screen_res.w;
    circle_tc_pos.x += 0.5;
    circle_tc_pos.zw = float2(0.5, 0.5); //position (center of the screen)
    circle_tc_pos.y -= 0.6; // push it down to bottom 1/3 of screen
    
    //circle settings
    float radius = breath_control.x;
    float distFromCenter = distance(circle_tc_pos.xy, float2(0.5, 0.5)); // get distance between cur pos and approx center of circle
    float fbmFactor = fbm(texcoord * (0.1 * (1.0 / seed)), 15);

    //draw circle
    radius *= fbmFactor; // apply wiggliness
    float circle = 1.0 - smoothstep(radius, radius + 0.08, length(circle_tc_pos.xy - circle_tc_pos.zw));
    float4 circleTex = float4(circle, circle, circle, 1.0); //cast to float3
    
    // debug
    //image = float4(0.);
    //image_blur = float4(0.);

    float centerRadius = clamp(radius - distFromCenter, 0.0, 1.0);
    circle_tc_pos.xy += radius; // todo: shift where we sample the texture randomly so each breath looks unique
    float4 glossyTex = s_breath_noise.Sample(smp_rtlinear, circle_tc_pos.xy); // reuse noise texture as regular one

    for (int i = 0; i < int(s_num_lights); i++)
    {
        float4 lightColor = s_lights_color[i];
        float4 lightPos = s_lights_pos[i];

        float lightCircle = 1.0 - step(0.125, length(I.tc0.xy - lightPos.xy));

        glossyTex += lightColor * lightCircle;
    }

    // transform sun world space to view space
    float4 sunProj = mul(m_VP, float4(L_sun_dir_w.xyz, 0.0));
    sunProj.xyz /= sunProj.w;
    sunProj.xy = sunProj.xy * float2(0.5, -0.5) + 0.5;
    // make a circle
    float sunCircle = 1.0 - step(0.125, length(I.tc0.xy - sunProj.xy));
    // add the circle
    glossyTex += float4(L_sun_color.xyz * L_sun_color.w, 1.0) * sunCircle * saturate(dot(-eye_direction, normalize(L_sun_dir_w.xyz - eye_position.xyz)));

    image_blur = lerp(image_blur, glossyTex, .25);
    image = lerp(image, image_blur, circleTex.xyz); // add our blurred area to the main texture
	return float4(image.xyz,1.0);
} 
