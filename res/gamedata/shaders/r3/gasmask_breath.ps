/*
    Gasmask breath shader
    
    Credits: yohjimane

    /////////////////
    OpenXRay Engine 2023
    /////////////////
*/

#include "common.h"
#include "gasmask_common.h"
//#define yohji_debug;

float fbm(float2 texcoord, int iterations) 
{
	float3 image_noise = s_breath_noise.Sample(smp_rtlinear, texcoord).xyz;
    float value = image_noise.x;
    float amplitude = 1.0;
    float frequency = 1.25; //play with is
    float total_weight = 2.5;

    for (int i = 0; i < iterations; i++) 
    {
        value += image_noise.x * amplitude;
        texcoord *= frequency;
        amplitude *= 1.25; //with this thing too
        total_weight += amplitude;
    }
    return value / total_weight;
}

float4 main(p_screen I) : SV_Target
{
    //texcoord
    float2 texcoord = I.tc0;
    float3 image = s_image.Sample(smp_rtlinear, texcoord).xyz;
    float3 image_blur = s_image_blurred.Sample(smp_rtlinear, texcoord).xyz;
    texcoord = applyInertia(texcoord);

    float3 breathNoise = s_breath_noise.Sample(smp_rtlinear, texcoord).xyz;
    float2 seed = breathNoise.xy;
    float breath_idx = breath_control.w;
    seed = frac(seed + float2(breath_idx, breath_idx) * 0.38196601125); // disable to stop generating new versions
    
    //ratio correction (remember that only circle tc should be corrected)
    float4 circle_tc_pos;
    circle_tc_pos.xy = I.tc0; //texcoord
    circle_tc_pos.x -= 0.5;
    circle_tc_pos.x *= screen_res.x * screen_res.w;
    circle_tc_pos.x += 0.5;
    circle_tc_pos.zw = float2(0.5, 0.5); //position (center of the screen)
    circle_tc_pos.y -= 0.6; // push it down to bottom 1/3 of screen
    
    //circle settings
    float radius = breath_control.x * 0.66;
#ifdef yohji_debug
    // set static size for breath fog
    radius = 1.0;
#endif
    float distFromCenter = distance(circle_tc_pos.xy, float2(0.5, 0.5)); // get distance between cur pos and approx center of circle
    float fbmFactor = fbm(texcoord * (0.1 * (1.0 / seed)), 15);

    //draw circle
    radius *= fbmFactor; // apply wiggliness
    float circle = 1.0 - smoothstep(radius, radius + 0.08, length(circle_tc_pos.xy - circle_tc_pos.zw));
    float4 circleTex = float4(circle, circle, circle, 1.0); //cast to float3

    float centerRadius = clamp(radius - distFromCenter, 0.0, 1.0);
    circle_tc_pos.xy += radius; // todo: shift where we sample the texture randomly so each breath looks unique
    float4 glossyTex = s_breath_noise.Sample(smp_rtlinear, circle_tc_pos.xy); // reuse noise texture as regular one
    glossyTex = lerp(glossyTex, float4(1.0, 1.0, 1.0, 1.0), 0.5);
#ifdef yohji_debug
    // set static color for breath fog
    glossyTex = float4(0,0,0,1);
#endif

    float2 tmp_pos = I.tc0;
    tmp_pos.xy = texcoord; //texcoord
    tmp_pos.x -= 0.5;
    tmp_pos.x *= screen_res.x * screen_res.w;
    tmp_pos.x += 0.5;

    for (int i = 0; i < int(s_num_lights); i++)
    {
        float4 lightColor = s_lights_color[i];
        float4 lightPos = s_lights_pos[i];
        float lightInfluenceRadius = fbmFactor * lightPos.z; // multiply by light range to get approx radius

        //smoothstep(radius, radius + 0.08, length(I.tc0.xy - lightPos.xy))
        float lightCircle = 1.0 - smoothstep(lightInfluenceRadius, lightInfluenceRadius + lightInfluenceRadius, length(tmp_pos - lightPos.xy));
#ifdef yohji_debug
        lightColor = float4(0,1,0,1); // set light color to green in debug mode
#endif
        glossyTex += (lightColor * lightColor.w * lightPos.w) * lightCircle; // multiply by fade factor and reciprocal distance so the lit area grows as we get farther
    }

    // transform sun world space to view space
    float sunRadius = 0.5;
    float4 sunProj = mul(m_VP, float4(L_sun_dir_w.xyz, 0.0));
    sunProj.xyz /= sunProj.w;
    sunProj.xy = sunProj.xy * float2(0.5, -0.5) + 0.5;

    float sunCircle = 1.0 - smoothstep(sunRadius, sunRadius + sunRadius, length(tmp_pos - sunProj.xy));
    float3 sunColor = L_sun_color.xyz;
#ifdef yohji_debug
    sunColor = float3(1,0,0); // set sun color to red in debug mode
#endif

    sunColor *= L_sun_color.w; // multiply by fade factor
    glossyTex += float4(sunColor, 1.0) * sunCircle * saturate(dot(-eye_direction, normalize(L_sun_dir_w.xyz - eye_position.xyz)));

    image_blur = lerp(image_blur, glossyTex, .25);
    image = lerp(image, image_blur, circleTex.xyz); // add our blurred area to the main texture
	return float4(image.xyz,1.0);
} 
